# 160.链表相交
编写一个程序，找到两个单链表相交的起始节点。    
如下面的两个链表：    
A:{1,2,3,4,5}    
B:{6,4,5}    
在节点 c1 开始相交。    
例如 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3   

## 题目解析
其实这道题它让人很困惑，因为给出的例子都是尾部一直相交的情况，并且相交与否由输入给出，在某些情况下，即使结点数值相同，也不一定相交，
所以干脆不考虑相交后相离的情况，默认尾部要么一直相交要么不交   

## 解题方法
在查看官方解题思路时，官方给出了一个很有意思的想法——*双指针解法*
```
创建两个指针 pA 和 pB，分别初始化为链表 A 和 B 的头结点。然后让它们向后逐结点遍历。
当 pA 到达链表的尾部时，将它重定位到链表 B 的头结点 (你没看错，就是链表 B); 类似的，当 pB 到达链表的尾部时，将它重定位到链表 A 的头结点。
若在某一时刻 pA 和 pB 相遇，则 pA/pB 为相交结点。
```
一开始的时候，并不能理解这个思路，直到后来，从另外一个图豁然开朗   
思路其实十分简单，在解题前我们怎么样画这两个交叉的链表呢，肯定是我们经过大脑的判断，将两个列表如下排列在纸上   
因为题目设定的是相交了知道链表结束两个都一直在相交，所以画出来的示意图是一个逆时针转90度的 **Y**

```
1 2 3 4 5  
    6 4 5  
```
 
由上可知，尾部两个结点相交，可以直接找到，双指针解法不同于暴力拆解或者哈希表法，它是模拟的我们大脑判断的解法    
1.先尾部对齐   
两个链表的长度不一致，但尾部一定相交，所以从尾部找起更加直接       
双指针实际上是形成了两个新的拼接链表A+B 与 B+A   
于是两个链表的总长度一致了，即尾部对齐了   

2.从头开始走就行
因为尾部对齐了，直接对比指针所在结点数值是否一致即可

## 代码
```
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) 
    {
        ListNode *a = headA, *b = headB;           //设置a,b链表的指针分别指向a,b头指针
        while(a != b)                              //判断指针是否相等即为判断是否相交
        {
            a = a? a->next : headB;                 //判断链表指针是否为空，不为空则后移，为空则指向另一链表头结点
            b = b? b->next : headA; 
        }
        return a;
    }
};

```

## 总结
这道题考察了链表基础使用，在基础娴熟的基础上，观察题目找到更为巧妙的解法    
方法有很多，我原来的想法是从后往前找相交结点，但是似乎时间复杂度过高   
先把两个指针依次后移直到尾部（不为空），然后再依次前移并判断是否相同  
上述方法设计的知识点有：三目运算符，循环，结构体，指针    
以上只是代码的重点函数片段   






